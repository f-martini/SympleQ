# flake8: noqa
import numpy as np
from sympleq.core.measurement.aquire import Aquire
from sympleq.core.paulis import PauliSum
from sympleq.core.paulis.utils import XZ_to_Y
from sympleq.core.measurement.covariance_graph import commutation_graph, weighted_vertex_covering_maximal_cliques
from sympleq.core.measurement.allocation import construct_circuit_list
from sympleq.core.measurement.allocation import sort_hamiltonian

import pytest


class TestAquire:

    def andrew_comparison(self, P, psi, correct_commutation_graph, correct_xxx, correct_circuit_list, correct_pdf_list,
                          simulated_measurement_results, correct_results):
        assert P.is_hermitian(), "P not hermitian"
        assert np.abs(np.linalg.norm(psi) - 1) < 10**(-6), "psi not normalized"
        com_graph = commutation_graph(P)
        assert np.all(com_graph.adj == correct_commutation_graph), "commutation graphs do not match"
        clique_covering = weighted_vertex_covering_maximal_cliques(com_graph, cc=P.weights, k=200)
        xxx = sorted(clique_covering)
        assert xxx == correct_xxx, "Clique coverings do not match"
        circuit_list, circuit_dictionary = construct_circuit_list(P, xxx, {})
        for i, c in enumerate(circuit_list):
            comp_c = correct_circuit_list[i]
            for j, g in enumerate(c.gates):
                assert g.name == comp_c[j][0] and np.all(g.qudit_indices == comp_c[j][1]), f"Circuit {i} does not match"

        for i, aa in enumerate(xxx):
            P1, C, _ = circuit_dictionary[str(aa)]
            psi_diag = C.unitary() @ psi
            pdf = np.abs(psi_diag * psi_diag.conj())
            assert np.allclose(pdf, correct_pdf_list[i]), f"pdf does not match for clique {i}, {aa}"

        d = P.lcm

        for i, aa in enumerate(xxx):
            (P1, C, k_dict) = circuit_dictionary[str(aa)]
            p1, q1, phases1 = P1.n_paulis(), P1.n_qudits(), P1.phases

            bases_a1 = simulated_measurement_results[i]

            ss = [(sum((bases_a1[i1] * P1.z_exp[i0, i1] * P1.lcm) // P1.dimensions[i1]
                       for i1 in range(q1))) % P1.lcm for i0 in range(p1)]

            comp_correct_results = correct_results[i]
            j = 0
            for j0, s0 in enumerate(ss):
                for a0, a1, s1 in k_dict[str(j0)]:
                    assert (phases1[j0] + s1) % 2 != 1, f"Eigenvalue for {i} not even (not able to sort in correctly)"
                    assert (a0 == comp_correct_results[j][0] and a1 == comp_correct_results[j][1])
                    comp = (int(s0 + (phases1[j0] + s1) / 2) % d == comp_correct_results[j][2])
                    assert comp, f"Eigenvalue for clique {i} does not match"
                    j += 1
        pass

    def test_aquire_for_specific_mono_qubit(self):
        P = PauliSum.from_string(['x1z1 x1z1 x1z1',
                                  'x0z0 x0z0 x1z1',
                                  'x1z0 x0z0 x0z1',
                                  'x0z1 x0z0 x1z1',
                                  'x1z0 x1z1 x0z0',
                                  'x1z1 x0z0 x0z1',
                                  'x0z1 x1z1 x0z1',
                                  'x1z1 x1z1 x1z0',
                                  'x0z0 x1z1 x0z1',
                                  'x1z0 x0z0 x0z0'],
                                 weights=np.array([-0.34388439818889144,
                                                   0.7436298937001218,
                                                   0.6368784400120875,
                                                   -1.4522508519539838,
                                                   1.4385061679898403,
                                                   0.3582727125625741,
                                                   -1.7867060667726984,
                                                   -0.007452872866153432,
                                                   0.7142214737781517,
                                                   -1.037912906162262]),
                                 dimensions=[2, 2, 2],
                                 phases=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0])

        P = XZ_to_Y(P)

        P, _ = sort_hamiltonian(P)

        psi = np.array([0.28734121 + 0.47090487j,
                        0.13243124 + 0.16265234j,
                        0.31736028 + 0.06817234j,
                        0.15856433 + 0.23092504j,
                        0.02475586 + 0.14238585j,
                        0.08439654 + 0.39071894j,
                        0.00390126 + 0.52128723j,
                        0.12323018 + 0.01561604j])

        correct_cg = np.array([[1. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 0. + 0.j,
                                0. + 0.j, 0. + 0.j],
                               [1. + 0.j, 1. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j,
                                   0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j],
                               [1. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j,
                                   0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j],
                               [0. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j,
                                   1. + 0.j, 0. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j],
                               [0. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j, 1. + 0.j,
                                   0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j],
                               [0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 0. + 0.j,
                                   1. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 0. + 0.j],
                               [1. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j,
                                   0. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j],
                               [0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j,
                                   0. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j],
                               [0. + 0.j, 0. + 0.j, 1. + 0.j, 0. + 0.j, 1. + 0.j,
                                   1. + 0.j, 1. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j],
                               [0. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j, 1. + 0.j,
                                   0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j]])

        correct_xxx = [[0, 1], [0, 2], [0, 6], [1, 3], [1, 4, 9], [2, 3, 7], [2, 4, 8, 9], [3, 5],
                       [5, 8], [6, 7], [6, 8]]

        # Check that the circuits are the same
        correct_circuit_list = [[('S', [0]), ('S', [1]), ('S', [2]), ('H', [0]), ('H', [1]), ('H', [2])],
                                [('SUM', [0, 1]), ('SUM', [0, 2]), ('SUM', [1, 0]), ('SUM', [2, 0]), ('S', [0]),
                                ('SUM', [1, 2]), ('S', [1]), ('H', [0]), ('H', [1])],
                                [('SUM', [0, 1]), ('SUM', [0, 2]), ('SUM', [1, 0]), ('SUM', [2, 0]), ('S', [0]),
                                ('H', [0]), ('H', [1])],
                                [('S', [2]), ('H', [2])],
                                [('S', [1]), ('S', [2]), ('H', [0]), ('H', [1]), ('H', [2])],
                                [('S', [0]), ('SUM', [2, 0]), ('S', [0]), ('SUM', [1, 2]), ('S', [1]), ('H', [0]),
                                ('H', [1]), ('H', [2])],
                                [('S', [1]), ('H', [0]), ('H', [1])],
                                [('SUM', [2, 0]), ('S', [0]), ('H', [0]), ('H', [2])],
                                [('S', [0]), ('S', [1]), ('H', [0]), ('H', [1])],
                                [('SUM', [0, 1]), ('SUM', [0, 2]), ('S', [0]), ('SUM', [1, 0]), ('S', [0]), ('S', [1]),
                                ('SUM', [2, 1]), ('S', [1]), ('H', [0]), ('H', [1])],
                                [('S', [1]), ('H', [1])]]

        correct_pdf_list = [np.array([0.02542707, 0.12897405, 0.08068772, 0.05845028, 0.36295372, 0.1421931,
                                      0.05060223, 0.15071182]),
                            np.array([0.09318501, 0.30005449, 0.15304774, 0.17704009, 0.10752054, 0.07545655,
                                      0.06534823, 0.02834737]),
                            np.array([0.44466921, 0.21183354, 0.019566, 0.04725856, 0.09619328, 0.14315368,
                                      0.02446649, 0.01285923]),
                            np.array([0.18978089, 0.1585293, 0.02944028, 0.15439375, 0.09267961, 0.08799103,
                                      0.20776996, 0.07941517]),
                            np.array([0.25705659, 0.15511907, 0.1209376, 0.17569991, 0.1313242, 0.11604808,
                                      0.01035235, 0.03346219]),
                            np.array([0.04864252, 0.02594369, 0.05530455, 0.35704434, 0.17937638, 0.20819559,
                                      0.05100822, 0.07448471]),
                            np.array([0.23757947, 0.17459619, 0.22452135, 0.07211616, 0.23109066, 0.01628162,
                                      0.00913208, 0.03468246]),
                            np.array([0.26060613, 0.01264472, 0.03943729, 0.0049216, 0.23856419, 0.0171658,
                                      0.35724211, 0.06941816]),
                            np.array([0.02260509, 0.13179603, 0.13413112, 0.00500688, 0.44606504, 0.05908179,
                                      0.09952231, 0.10179175]),
                            np.array([0.09774939, 0.02266323, 0.20535566, 0.13638989, 0.26378004, 0.08830288,
                                      0.0180099, 0.16774901]),
                            np.array([0.33469847, 0.05644059, 0.07498291, 0.06602225, 0.13397166, 0.13443723,
                                      0.15867052, 0.04077638])]

        simulated_measurement_results = [np.array([1, 1, 1]),
                                         np.array([0, 1, 1]),
                                         np.array([0, 0, 0]),
                                         np.array([0, 0, 1]),
                                         np.array([0, 1, 1]),
                                         np.array([0, 1, 1]),
                                         np.array([0, 1, 1]),
                                         np.array([0, 0, 0]),
                                         np.array([1, 0, 0]),
                                         np.array([0, 1, 1]),
                                         np.array([1, 0, 0])]

        correct_results = [[[0, 0, 0], [1, 1, 0], [0, 1, 0], [1, 0, 0]],
                           [[0, 0, 0], [2, 2, 0], [0, 2, 0], [2, 0, 0]],
                           [[0, 0, 0], [6, 6, 1], [0, 6, 1], [6, 0, 1]],
                           [[1, 1, 0], [3, 3, 0], [1, 3, 0], [3, 1, 0]],
                           [[1, 1, 0], [4, 4, 0], [9, 9, 0], [1, 4, 0], [4, 1, 0],
                            [1, 9, 0], [9, 1, 0], [4, 9, 0], [9, 4, 0]],
                           [[2, 2, 1], [3, 3, 0], [7, 7, 1], [2, 3, 1], [3, 2, 1],
                            [2, 7, 0], [7, 2, 0], [3, 7, 1], [7, 3, 1]],
                           [[2, 2, 1], [4, 8, 1], [8, 4, 1], [4, 4, 0], [2, 8, 0], [8, 2, 0], [8, 8, 1], [2, 4, 1],
                            [4, 2, 1], [9, 9, 0], [2, 9, 1], [9, 2, 1], [4, 9, 0], [9, 4, 0], [8, 9, 1], [9, 8, 1]],
                           [[3, 3, 1], [5, 5, 1], [3, 5, 0], [5, 3, 0]],
                           [[5, 5, 0], [8, 8, 1], [5, 8, 1], [8, 5, 1]],
                           [[6, 6, 1], [7, 7, 0], [6, 7, 1], [7, 6, 1]],
                           [[6, 6, 0], [8, 8, 1], [6, 8, 1], [8, 6, 1]]]

        self.andrew_comparison(P, psi, correct_cg,
                               correct_xxx, correct_circuit_list,
                               correct_pdf_list, simulated_measurement_results, correct_results)

    def test_aquire_for_specific_mono_qudit(self):
        P = PauliSum.from_string(['x2z2 x2z0 x0z0 ',
                                  'x1z1 x1z0 x0z0 ',
                                  'x2z1 x1z2 x1z1 ',
                                  'x1z2 x2z1 x2z2 ',
                                  'x2z2 x1z0 x0z1 ',
                                  'x1z1 x2z0 x0z2 ',
                                  'x2z1 x0z2 x0z2 ',
                                  'x1z2 x0z1 x0z1 ',
                                  'x2z1 x0z1 x0z0 ',
                                  'x1z2 x0z2 x0z0 ',
                                  'x2z0 x0z0 x0z2 ',
                                  'x1z0 x0z0 x0z1 ',
                                  'x0z0 x2z1 x2z0 ',
                                  'x0z0 x1z2 x1z0 ',
                                  'x0z2 x2z2 x1z0 ',
                                  'x0z1 x1z1 x2z0 ',
                                  'x0z2 x2z0 x1z0 ',
                                  'x0z1 x1z0 x2z0 ',
                                  'x0z1 x2z0 x1z0 ',
                                  'x0z2 x1z0 x2z0 '],
                                 weights=np.array([-0.5+0.8660254j, 1. +0j, -0.5-0.8660254j, 1. +0j, -0.5+0.8660254j, 1. +0j,
                                                   -0.5-0.8660254j, 1. +0j, 1. +0j, -0.5-0.8660254j, 1. +0j, 1. +0j, -0.5-0.8660254j,
                                                   1. +0j, 1. +0j, -0.5+0.8660254j, 1. +0j, 1. +0j, 1. +0j, 1. +0j]),
                                 dimensions=[3,3,3])

        P, _ = sort_hamiltonian(P)

        assert P.is_hermitian()

        psi = np.array([0.0243169 + 0.13333766j, 0.23225686 + 0.01878849j, 0.14274615 + 0.20139411j,
                        0.21479966 + 0.16158387j, 0.04977999 + 0.22823104j, 0.18769378 + 0.05949222j,
                        0.15391192 + 0.06717867j, 0.09354094 + 0.1232698j, 0.05537587 + 0.21819983j,
                        0.00393039 + 0.01681437j, 0.19299884 + 0.18595263j, 0.17220807 + 0.19552373j,
                        0.01249742 + 0.06402695j, 0.03737155 + 0.09736036j, 0.17287483 + 0.02595331j,
                        0.1046728 + 0.04925145j, 0.14569767 + 0.01744369j, 0.13833252 + 0.05140952j,
                        0.19480008 + 0.11880762j, 0.17876016 + 0.06101845j, 0.19297524 + 0.12974931j,
                        0.09315548 + 0.16390813j, 0.10666972 + 0.17861801j, 0.17352167 + 0.02847061j,
                        0.04007118 + 0.20151664j, 0.06101652 + 0.03587477j, 0.23395682 + 0.04552155j])

        com_graph = commutation_graph(P)
        correct_commutation_graph = np.array([
            [1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j,
             0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j],
            [1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j,
             0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j],
            [0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j,
             1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j],
            [0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j,
             1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j],
            [1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j,
             0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j],
            [1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j,
             0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j],
            [0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j,
             0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j],
            [0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j,
             0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j],
            [1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j,
             0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j],
            [1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j,
             0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j],
            [0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j,
             1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j],
            [0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j,
             1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j],
            [0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j,
             0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j],
            [0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j,
             0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j],
            [0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j,
             0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j],
            [0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j,
             0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j],
            [0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j,
             0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j],
            [0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j,
             0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j],
            [0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j,
             1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j],
            [0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j,
             1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j]])

        assert np.all(com_graph.adj == correct_commutation_graph)

        # test that this is the same
        clique_covering = weighted_vertex_covering_maximal_cliques(com_graph, cc=P.weights, k=100)
        xxx = sorted(clique_covering)
        correct_xxx = [[0, 1, 4, 5], [0, 1, 8, 9], [2, 3, 10, 11, 18, 19], [4, 5, 6, 7], [
            4, 5, 16, 17], [6, 7, 8, 9], [8, 9, 18, 19], [12, 13], [14, 15], [16, 17, 18, 19]]
        assert xxx == correct_xxx

        # Check that the circuits are the same
        circuit_list, circuit_dictionary = construct_circuit_list(P, sorted(clique_covering), {})
        correct_circuit_list = [[('S', [0]), ('S', [0]), ('H', [0]), ('H', [1])],
                                [('SUM', [0, 1]), ('SUM', [0, 1]), ('S', [0]), ('S', [0]),
                                ('S', [1]), ('S', [1]), ('H', [0]), ('H', [1])],
                                [('SUM', [0, 1]), ('SUM', [0, 2]), ('SUM', [1, 0]), ('SUM', [2, 0]), ('SUM', [1, 0]), ('S', [0]), ('SUM', [1, 2]), ('SUM', [
                                    1, 2]), ('SUM', [2, 1]), ('SUM', [2, 1]), ('S', [1]), ('S', [1]), ('S', [2]), ('S', [2]), ('H', [0]), ('H', [1]), ('H', [2])],
                                [('SUM', [0, 1]), ('SUM', [2, 0]), ('SUM', [2, 0]), ('S', [0]), ('S', [0]),
                                ('SUM', [2, 1]), ('SUM', [2, 1]), ('S', [1]), ('S', [1]), ('H', [0]), ('H', [1])],
                                [('SUM', [0, 1]), ('SUM', [2, 0]), ('SUM', [2, 0]), ('S', [0]), ('S', [0]),
                                ('SUM', [1, 2]), ('SUM', [2, 1]), ('SUM', [2, 1]), ('S', [1]), ('H', [0]), ('H', [1])],
                                [('S', [0]), ('H', [0])],
                                [('SUM', [1, 0]), ('S', [0]), ('SUM', [1, 2]),
                                ('S', [1]), ('S', [1]), ('H', [0]), ('H', [1])],
                                [('S', [1]), ('H', [1]), ('H', [2])],
                                [('S', [1]), ('S', [1]), ('H', [1]), ('H', [2])],
                                [('H', [1]), ('H', [2])]]

        for i,c in enumerate(circuit_list):
            comp_c = correct_circuit_list[i]
            for j, g in enumerate(c.gates):
                assert g.name == comp_c[j][0] and np.all(g.qudit_indices == comp_c[j][1])

        correct_pdf_list = [np.array([6.59161444e-02, 8.02150363e-02, 6.36243965e-02, 2.17680172e-02, 3.29055261e-03, 1.87546042e-02, 7.74362539e-03, 6.53314911e-03, 9.75691566e-05, 3.65793915e-02, 8.17840670e-02, 1.90521408e-01, 8.62538668e-03, 4.91780968e-03, 1.51418111e-03, 4.74498174e-04, 2.90909439e-03, 1.76982765e-02, 1.17257790e-01, 7.33296223e-02, 1.08717592e-01, 5.81814011e-03, 7.10622581e-03, 1.12549611e-02, 2.39404690e-03, 6.09294875e-02, 2.24925503e-04]),
                            np.array([0.0135236, 0.02287538, 0.07313852, 0.04144613, 0.0231289, 0.01759941, 0.01723905, 0.04422607, 0.0018397, 0.02358743, 0.06587151, 0.08546266, 0.03688045,
                                     0.07318583, 0.02919063, 0.00027358, 0.00694677, 0.09484765, 0.03822441, 0.02253941, 0.03143263, 0.08353259, 0.00718997, 0.04605496, 0.01186979, 0.0550512 , 0.03284175]),
                            np.array([0.01227258, 0.02210411, 0.03213838, 0.06253631, 0.10663692, 0.00464668, 0.03475378, 0.03085721, 0.01632825, 0.0459643 , 0.02044448, 0.02630505, 0.10628538,
                                     0.07778881, 0.05519194, 0.0268313 , 0.03817419, 0.03587107, 0.04349402, 0.03996942, 0.02044398, 0.02971498, 0.02362896, 0.00387816, 0.00729071, 0.06502106, 0.01142796]),
                            np.array([0.02048224, 0.04212302, 0.00216514, 0.02993187, 0.02600585, 0.0937533 , 0.02652146, 0.02729458, 0.04925203, 0.01080454, 0.02335932, 0.01623029, 0.01961622,
                                     0.0318068 , 0.01798273, 0.0197204 , 0.02436314, 0.03115049, 0.01154127, 0.00023335, 0.09768908, 0.0764049 , 0.08936188, 0.06315144, 0.05155413, 0.05646711, 0.04103342]),
                            np.array([0.0383909 , 0.04210919, 0.01590876, 0.04815273, 0.00930026, 0.01955169, 0.04754097, 0.0262308 , 0.07034419, 0.02917794, 0.00520156, 0.01829537, 0.04812309,
                                     0.01097835, 0.00655751, 0.02665757, 0.03412917, 0.01591336, 0.0268926 , 0.12949704, 0.01738394, 0.02872738, 0.07491332, 0.12835941, 0.00759387, 0.03682382, 0.03724521]),
                            np.array([0.03230439, 0.0627921 , 0.08680755, 0.01727597, 0.04087597, 0.03704394, 0.0022125 , 0.0208018 , 0.06780238, 0.03404063, 0.01575433, 0.05092214, 0.05108074,
                                     0.05179103, 0.03804879, 0.04061216, 0.02698124, 0.05296111, 0.00438572, 0.08325521, 0.04516584, 0.04369099, 0.01605894, 0.02515518, 0.04097395, 0.00270442, 0.00850099]),
                            np.array([0.01944395, 0.05153482, 0.07873739, 0.05333112, 0.03358082, 0.03947276, 0.00028253, 0.03725819, 0.06136238, 0.02834517, 0.02212939, 0.02856431, 0.02728588,
                                     0.03669945, 0.00850745, 0.02436656, 0.06841886, 0.03212182, 0.032282  , 0.0400476 , 0.02629502, 0.03128373, 0.02772186, 0.02192118, 0.00484517, 0.08572282, 0.07843777]),
                            np.array([0.09564645, 0.00399907, 0.00264297, 0.09677284, 0.00824304, 0.03561417, 0.12410063, 0.005804  , 0.0291882 , 0.09247727, 0.02202712, 0.00608497, 0.06816354,
                                     0.0049469 , 0.02109672, 0.02090848, 0.00333723, 0.00335163, 0.10731017, 0.00119354, 0.00468997, 0.07647734, 0.00229109, 0.02503225, 0.11158595, 0.01187198, 0.01514246]),
                            np.array([0.13601593, 0.00555376, 0.00689171, 0.0949811 , 0.00979787, 0.02425467, 0.0855229 , 0.00269447, 0.03629897, 0.03176591, 0.01854943, 0.00352163, 0.07124663,
                                     0.00693303, 0.0197805 , 0.07853676, 0.00482879, 0.00723117, 0.12189132, 0.00124994, 0.01543726, 0.05340347, 0.01033514, 0.02304362, 0.12007868, 0.00377153, 0.0063838]),
                            np.array([3.11151518e-01, 1.82878877e-03, 1.06575490e-03, 3.43664166e-04, 1.28398168e-04, 5.38554170e-02, 5.02474774e-03, 1.60889224e-02, 1.25241711e-02, 1.61865503e-01, 1.92320068e-02, 9.44542185e-03, 1.15377437e-03, 6.27698323e-03, 1.17308916e-02, 1.85300175e-02, 4.80226348e-03, 9.35699814e-03, 2.83749116e-01, 4.85501400e-03, 2.47523249e-02, 2.08454105e-03, 5.52640626e-03, 1.94980266e-03, 9.53981418e-03, 4.97518792e-03, 1.81625502e-02])]

        for i,aa in enumerate(xxx):
            P1, C, _ = circuit_dictionary[str(aa)]
            psi_diag = C.unitary() @ psi
            pdf = np.abs(psi_diag * psi_diag.conj())
            assert np.allclose(pdf, correct_pdf_list[i])

        simulated_measurement_results = [np.array([0, 0, 1]),
                                         np.array([1, 1, 0]),
                                         np.array([1, 1, 1]),
                                         np.array([2, 2, 1]),
                                         np.array([2, 0, 1]),
                                         np.array([2, 1, 2]),
                                         np.array([2, 0, 2]),
                                         np.array([2, 2, 0]),
                                         np.array([0, 0, 0]),
                                         np.array([2, 0, 0])]

        d = P.lcm

        correct_results = [[[0, 0, 2], [0, 1, 1], [1, 1, 0], [1, 0, 2], [4, 4, 0], [4, 5, 2], [5, 5, 2], [5, 4, 1], [0, 4, 1], [5, 1, 1], [0, 5, 0], [4, 1, 0], [1, 4, 0], [5, 0, 0], [1, 5, 2], [4, 0, 2]],
                           [[0, 0, 1], [0, 1, 0], [1, 1, 1], [1, 0, 0], [8, 8, 2], [8, 9, 0], [9, 9, 2], [9, 8, 0], [
                               0, 8, 1], [9, 1, 2], [0, 9, 1], [8, 1, 2], [1, 8, 1], [9, 0, 2], [1, 9, 1], [8, 0, 2]],
                           [[2, 2, 0], [2, 3, 1], [3, 3, 1], [3, 2, 2], [10, 10, 1], [10, 11, 1], [11, 11, 2], [11, 10, 2], [18, 18, 1], [18, 19, 1], [19, 19, 2], [19, 18, 2], [2, 10, 1], [11, 3, 2], [2, 11, 2], [10, 3, 0], [2, 18, 1], [19, 3, 2], [
                               2, 19, 2], [18, 3, 0], [3, 10, 0], [11, 2, 1], [3, 11, 1], [10, 2, 2], [3, 18, 0], [19, 2, 1], [3, 19, 1], [18, 2, 2], [10, 18, 0], [19, 11, 0], [10, 19, 1], [18, 11, 1], [11, 18, 2], [19, 10, 2], [11, 19, 0], [18, 10, 0]],
                           [[4, 4, 0], [4, 5, 2], [5, 5, 2], [5, 4, 1], [6, 6, 0], [6, 7, 1], [7, 7, 1], [7, 6, 2], [
                               4, 6, 0], [7, 5, 1], [4, 7, 1], [6, 5, 2], [5, 6, 1], [7, 4, 2], [5, 7, 2], [6, 4, 0]],
                           [[4, 4, 0], [4, 5, 2], [5, 5, 2], [5, 4, 1], [16, 16, 1], [16, 17, 1], [17, 17, 2], [17, 16, 2], [
                               4, 16, 1], [17, 5, 0], [4, 17, 2], [16, 5, 1], [5, 16, 2], [17, 4, 1], [5, 17, 0], [16, 4, 2]],
                           [[6, 6, 2], [6, 7, 0], [7, 7, 2], [7, 6, 0], [8, 8, 0], [8, 9, 1], [9, 9, 1], [9, 8, 2], [
                               6, 8, 1], [9, 7, 1], [6, 9, 2], [8, 7, 2], [7, 8, 1], [9, 6, 1], [7, 9, 2], [8, 6, 2]],
                           [[8, 8, 2], [8, 9, 0], [9, 9, 2], [9, 8, 0], [18, 18, 1], [18, 19, 1], [19, 19, 2], [19, 18, 2], [
                               8, 18, 2], [19, 9, 0], [8, 19, 0], [18, 9, 1], [9, 18, 2], [19, 8, 0], [9, 19, 0], [18, 8, 1]],
                           [[12, 12, 2], [12, 13, 0], [13, 13, 2], [13, 12, 0]],
                           [[14, 14, 2], [14, 15, 1], [15, 15, 0], [15, 14, 2]],
                           [[16, 16, 1], [16, 17, 1], [17, 17, 2], [17, 16, 2], [18, 18, 2], [18, 19, 2], [19, 19, 1], [19, 18, 1], [16, 18, 1], [19, 17, 1], [16, 19, 0], [18, 17, 0], [17, 18, 0], [19, 16, 0], [17, 19, 2], [18, 16, 2]]]

        for i, aa in enumerate(xxx):
            (P1, C, k_dict) = circuit_dictionary[str(aa)]
            p1, q1, phases1 = P1.n_paulis(), P1.n_qudits(), P1.phases

            bases_a1 = simulated_measurement_results[i]

            ss = [(sum((bases_a1[i1] * P1.z_exp[i0, i1] * P1.lcm) // P1.dimensions[i1]
                       for i1 in range(q1))) % P1.lcm for i0 in range(p1)]

            comp_correct_results = correct_results[i]
            j = 0
            for j0, s0 in enumerate(ss):
                for a0, a1, s1 in k_dict[str(j0)]:
                    assert (phases1[j0] + s1) % 2 != 1
                    assert (a0 == comp_correct_results[j][0] and a1 == comp_correct_results[j][1] and int(
                        s0 + (phases1[j0]+s1)/2)%d == comp_correct_results[j][2])
                    j += 1

        self.andrew_comparison(P, psi, correct_commutation_graph,
                               correct_xxx, correct_circuit_list,
                               correct_pdf_list, simulated_measurement_results, correct_results)

    def test_aquire_for_specific_mixed_qubit_qutrit(self):
        # Mixed true test
        P = PauliSum.from_string(['x1z0 x1z1 x1z2 x2z2 ',
                                  'x1z0 x1z1 x2z1 x1z1 ',
                                  'x1z1 x0z1 x2z1 x0z2 ',
                                  'x1z1 x0z1 x1z2 x0z1 ',
                                  'x1z1 x1z1 x2z2 x0z1 ',
                                  'x1z1 x1z1 x1z1 x0z2 ',
                                  'x0z1 x1z1 x0z0 x1z0 ',
                                  'x0z1 x1z1 x0z0 x2z0 ',
                                  'x0z0 x0z1 x1z2 x2z0 ',
                                  'x0z0 x0z1 x2z1 x1z0 ',
                                  'x0z1 x0z0 x1z0 x1z2 ',
                                  'x0z1 x0z0 x2z0 x2z1 ',
                                  'x1z0 x1z0 x2z1 x0z2 ',
                                  'x1z0 x1z0 x1z2 x0z1 ',
                                  'x0z0 x0z1 x1z1 x1z0 ',
                                  'x0z0 x0z1 x2z2 x2z0 ',
                                  'x0z1 x1z1 x0z2 x1z0 ',
                                  'x0z1 x1z1 x0z1 x2z0 ',
                                  'x1z1 x1z0 x0z2 x2z1 ',
                                  'x1z1 x1z0 x0z1 x1z2 '],
                                 weights=np.array([1. +0.j, 1. +0.j, 1. +0.j,
                                                  -0.5-0.8660254j, 1. +0.j, -0.5+0.8660254j,
                                                  1. +0.j, 1. +0.j, 1. +0.j,
                                                  -0.5-0.8660254j, 1. +0.j, -0.5-0.8660254j,
                                                  1. +0.j, -0.5-0.8660254j, 1. +0.j,
                                                  -0.5+0.8660254j, 1. +0.j, 1. +0.j,
                                                  1. +0.j, -0.5-0.8660254j]),
                                 dimensions=[2,2,3,3],
                                 phases=np.array([3, 3, 3, 3, 6, 6, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3]))
        #P.phase_to_weight()

        P, _ = sort_hamiltonian(P)

        print(P)
        print()

        psi = np.array([0.11500296+0.158842j  , 0.11891315+0.04645248j,
                        0.16339187+0.18320673j, 0.09787282+0.03129713j,
                        0.02921919+0.17185505j, 0.14037918+0.17957415j,
                        0.16975852+0.1203281j , 0.08112145+0.01495658j,
                        0.12482631+0.03777704j, 0.17725109+0.08709215j,
                        0.05708134+0.21102912j, 0.11241009+0.14913532j,
                        0.00379633+0.0084785j , 0.14080888+0.13034763j,
                        0.09452691+0.01318673j, 0.02730901+0.10283776j,
                        0.06685344+0.19232163j, 0.0723869 +0.03907354j,
                        0.21170456+0.00571245j, 0.13218704+0.00616202j,
                        0.15236543+0.16851648j, 0.04088296+0.03798313j,
                        0.08279305+0.0028202j , 0.00076583+0.05322017j,
                        0.14580718+0.07922759j, 0.12288661+0.15448631j,
                        0.16739977+0.05103957j, 0.01458575+0.20026341j,
                        0.00590871+0.20618361j, 0.14890498+0.17562346j,
                        0.07864298+0.07497451j, 0.20666831+0.01095936j,
                        0.04445104+0.14454396j, 0.01357817+0.01864348j,
                        0.07358836+0.05238865j, 0.19724755+0.11331716j])

        psi = psi/np.linalg.norm(psi)

        correct_commutation_graph = np.array([[1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,
                                               0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j],
                                              [1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,
                                             0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j],
                                              [0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,
                                             0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,
                                               0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,
                                               0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,
                                               0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j,
                                               0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j,
                                               0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j,
                                               0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j,
                                               0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,
                                               1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,
                                               1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,
                                               0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,
                                               0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,
                                               0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,
                                               0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j,
                                               1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j,
                                               1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],
                                              [1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,
                                               0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j],
                                              [1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,
                                             0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j]])

        correct_xxx = [[0, 1, 18, 19], [2, 3, 12, 13], [4, 5], [6, 7, 16, 17], [8, 9], [10, 11, 16, 17], [14, 15]]

        correct_circuit_list = [[('SUM', [0, 1]), ('SUM', [1, 0]), ('S', [0]), ('SUM', [2, 3]), ('S', [2]), ('SUM', [3, 2]), ('SUM', [3, 2]), ('S', [2]), ('S', [2]), ('S', [3]), ('S', [3]), ('H', [0]), ('H', [2]), ('H', [3])],
                                [('SUM', [1, 0]), ('S', [0]), ('SUM', [3, 2]), ('SUM', [3, 2]),
                                ('S', [2]), ('H', [0]), ('H', [1]), ('H', [2])],
                                [('S', [0]), ('S', [1]), ('S', [2]), ('S', [2]), ('H', [0]), ('H', [1]), ('H', [2])],
                                [('S', [1]), ('H', [1]), ('H', [3])],
                                [('S', [2]), ('H', [2]), ('H', [3])],
                                [('S', [1]), ('SUM', [2, 3]), ('SUM', [2, 3]), ('SUM', [3, 2]),
                                ('S', [2]), ('S', [3]), ('S', [3]), ('H', [1]), ('H', [2]), ('H', [3])],
                                [('S', [2]), ('S', [2]), ('H', [2]), ('H', [3])]]

        correct_pdf_list = [np.array([0.00666788, 0.01235884, 0.03125995, 0.02975805, 0.01606143, 0.09525113, 0.00345401, 0.02359132, 0.01628877, 0.01746348, 0.0113786 , 0.0346908 , 0.01132333, 0.04122629, 0.01308905, 0.00168192, 0.00150229, 0.00990941, 0.04078597, 0.02586482, 0.03696135, 0.01309442, 0.021667  , 0.04534856, 0.05171118, 0.02652489, 0.05220314, 0.01734654, 0.04157769, 0.02458423, 0.04128101, 0.10695461, 0.00628157, 0.01316015, 0.02512383, 0.03257252]),
                            np.array([0.04703918, 0.02606936, 0.07180096, 0.10241201, 0.0266485 , 0.02323808, 0.02506109, 0.06791508, 0.10131994, 0.00107674, 0.01674385, 0.00211389, 0.01515073, 0.00457002, 0.00075355, 0.01228573, 0.00960726, 0.00122202,
                                     0.01823503, 0.03549085, 0.04398356, 0.01571382, 0.04909463, 0.03993081, 0.02568788, 0.04675311, 0.09081742, 0.00011455, 0.00283844, 0.0054043 , 0.00324863, 0.00753902, 0.00062624, 0.00485552, 0.04316604, 0.01147218]),
                            np.array([0.00900418, 0.03432296, 0.01794393, 0.00572249, 0.05852523, 0.02016071, 0.03471484, 0.00574026, 0.02122991, 0.02336764, 0.04544896, 0.02518589, 0.02897808, 0.04133682, 0.03566739, 0.03532373, 0.01722683, 0.0580456 ,
                                     0.00808833, 0.00811984, 0.03065341, 0.0334142 , 0.01914267, 0.03738311, 0.00371889, 0.00310074, 0.06986495, 0.05023952, 0.03114611, 0.00632006, 0.00140045, 0.015484  , 0.02745177, 0.03690852, 0.05684175, 0.04277622]),
                            np.array([9.05130344e-02, 9.39138089e-03, 1.03629526e-02, 6.66730930e-02, 3.49668284e-02, 2.61902882e-03, 1.95092863e-02, 4.16643647e-03, 8.73582476e-03, 1.19172184e-01, 5.80083824e-04, 6.66853816e-03, 3.27643609e-02, 1.09077309e-04, 1.78048866e-03, 8.40093488e-02, 9.69536296e-03, 5.38632374e-04,
                                     2.16195442e-02, 2.34661709e-02, 8.64500039e-03, 3.18063435e-02, 5.24135902e-03, 9.96290454e-03, 6.45544796e-02, 3.99813498e-03, 4.61886335e-03, 1.93818505e-01, 1.53778079e-03, 7.69927661e-04, 3.02567947e-02, 5.45246042e-03, 7.59653279e-03, 6.41582409e-02, 1.12943115e-02, 8.94671219e-03]),
                            np.array([0.12524432, 0.00398469, 0.00846456, 0.05077393, 0.02022755, 0.00699995, 0.05661931, 0.00162275, 0.0010888 , 0.0419617 , 0.01106537, 0.00149873, 0.10016479, 0.0123614 , 0.01228116, 0.03787725, 0.0096474 , 0.00037226,
                                     0.03157235, 0.01414598, 0.00368902, 0.0998473 , 0.00310991, 0.00135006, 0.06004711, 0.00743912, 0.00271638, 0.10815618, 0.00319685, 0.00616948, 0.09838956, 0.02049074, 0.00127302, 0.00820141, 0.00260761, 0.02534199]),
                            np.array([0.08264691, 0.00046424, 0.03840515, 0.00721731, 0.02466197, 0.00219087, 0.01813537, 0.04937791, 0.02383814, 0.04194644, 0.02060812, 0.00919601, 0.02591444, 0.03359553, 0.04093039, 0.00633673, 0.03694306, 0.03984736,
                                     0.00323743, 0.00143319, 0.01762301, 0.01537575, 0.01501889, 0.0226235 , 0.01180759, 0.00561884, 0.08117461, 0.07124917, 0.00790138, 0.01709252, 0.04536543, 0.00409424, 0.10415778, 0.02113428, 0.03281073, 0.02002575]),
                            np.array([5.79994894e-02, 1.42392751e-02, 8.31182476e-04, 6.78030417e-02, 8.40349533e-03, 7.44115731e-03, 1.06835026e-01, 3.19222253e-03, 8.28096778e-03, 7.89162247e-02, 1.20805306e-03, 6.24898073e-03, 4.28199940e-02, 3.14305359e-02, 5.28595359e-03, 5.82675315e-02, 4.35587945e-04, 2.61722353e-03, 5.35408242e-02, 7.48582304e-03, 7.37037782e-03, 2.66165152e-02, 7.67116314e-03, 3.25931094e-04, 1.11309413e-01, 9.53802855e-03, 5.91439082e-05, 5.46242428e-02, 5.16711988e-03, 2.20924748e-03, 1.18753397e-01, 1.46644893e-03, 6.64929276e-03, 4.13695158e-02, 1.96616341e-02, 2.39259479e-02])]

        simulated_measurement_results = [np.array([0, 1, 0, 0]),
                                         np.array([0, 0, 0, 2]),
                                         np.array([0, 0, 1, 2]),
                                         np.array([0, 1, 0, 0]),
                                         np.array([0, 0, 0, 0]),
                                         np.array([1, 1, 1, 2]),
                                         np.array([1, 0, 0, 0])]

        correct_results = [[[0, 0, 3], [1, 1, 3], [18, 18, 4], [19, 19, 4], [0, 1, 0], [0, 18, 1], [19, 1, 5], [0, 19, 1], [18, 1, 5], [1, 0, 0], [1, 18, 1], [19, 0, 5], [1, 19, 1], [18, 0, 5], [18, 19, 0], [19, 18, 0]],
                           [[2, 2, 5], [3, 3, 3], [12, 12, 2], [13, 13, 0], [2, 3, 4], [12, 13, 4], [2, 12, 3], [3, 13, 3], [
                               12, 2, 3], [13, 3, 3], [2, 13, 1], [12, 3, 1], [3, 2, 2], [13, 12, 2], [3, 12, 5], [13, 2, 5]],
                           [[4, 4, 0], [5, 5, 4], [4, 5, 4], [5, 4, 2]],
                           [[6, 6, 0], [7, 7, 0], [16, 16, 0], [17, 17, 0], [6, 7, 0], [6, 16, 0], [17, 7, 0], [6, 17, 0], [
                               16, 7, 0], [7, 6, 0], [7, 16, 0], [17, 6, 0], [7, 17, 0], [16, 6, 0], [16, 17, 0], [17, 16, 0]],
                           [[8, 8, 0], [9, 9, 2], [8, 9, 2], [9, 8, 4]],
                           [[10, 10, 5], [11, 11, 3], [16, 16, 3], [17, 17, 3], [10, 11, 4], [10, 16, 4], [17, 11, 0], [10, 17, 4], [
                               16, 11, 0], [11, 10, 2], [11, 16, 0], [17, 10, 2], [11, 17, 0], [16, 10, 2], [16, 17, 0], [17, 16, 0]],
                           [[14, 14, 0], [15, 15, 4], [14, 15, 4], [15, 14, 2]]]

        self.andrew_comparison(P, psi, correct_commutation_graph, correct_xxx, correct_circuit_list, correct_pdf_list,
                               simulated_measurement_results, correct_results)

    def test_aquire_for_specific_mixed_qubit_qudit_2(self):
        pass