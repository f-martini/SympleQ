import numpy as np
from sympleq.core.measurement.aquire import Aquire
from sympleq.core.paulis import PauliSum
from sympleq.core.paulis.utils import XZ_to_Y
from sympleq.core.measurement.covariance_graph import commutation_graph, weighted_vertex_covering_maximal_cliques
from sympleq.core.measurement.allocation import construct_circuit_list
from sympleq.core.measurement.allocation import sort_hamiltonian

import pytest


class TestAquire:

    def test_aquire_for_specific_mono_qubit(self):
        P = PauliSum(['x1z1 x1z1 x1z1',
                      'x0z0 x0z0 x1z1',
                      'x1z0 x0z0 x0z1',
                      'x0z1 x0z0 x1z1',
                      'x1z0 x1z1 x0z0',
                      'x1z1 x0z0 x0z1',
                      'x0z1 x1z1 x0z1',
                      'x1z1 x1z1 x1z0',
                      'x0z0 x1z1 x0z1',
                      'x1z0 x0z0 x0z0'],
                     weights=np.array([-0.34388439818889144,
                                      0.7436298937001218,
                                      0.6368784400120875,
                                      -1.4522508519539838,
                                      1.4385061679898403,
                                      0.3582727125625741,
                                      -1.7867060667726984,
                                      -0.007452872866153432,
                                      0.7142214737781517,
                                      -1.037912906162262]),
                     dimensions=[2, 2, 2],
                     phases=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                     standardise=False)

        P = XZ_to_Y(P)

        P, _ = sort_hamiltonian(P)

        psi = np.array([0.28734121 + 0.47090487j,
                        0.13243124 + 0.16265234j,
                        0.31736028 + 0.06817234j,
                        0.15856433 + 0.23092504j,
                        0.02475586 + 0.14238585j,
                        0.08439654 + 0.39071894j,
                        0.00390126 + 0.52128723j,
                        0.12323018 + 0.01561604j])

        # test this
        com_graph = commutation_graph(P)
        correct_cg = np.array([[1. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 0. + 0.j,
                                0. + 0.j, 0. + 0.j],
                               [1. + 0.j, 1. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j,
                                   0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j],
                               [1. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j,
                                   0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j],
                               [0. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j,
                                   1. + 0.j, 0. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j],
                               [0. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j, 1. + 0.j,
                                   0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j],
                               [0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 0. + 0.j,
                                   1. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 0. + 0.j],
                               [1. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j,
                                   0. + 0.j, 1. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j],
                               [0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j,
                                   0. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j, 0. + 0.j],
                               [0. + 0.j, 0. + 0.j, 1. + 0.j, 0. + 0.j, 1. + 0.j,
                                   1. + 0.j, 1. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j],
                               [0. + 0.j, 1. + 0.j, 1. + 0.j, 0. + 0.j, 1. + 0.j,
                                   0. + 0.j, 0. + 0.j, 0. + 0.j, 1. + 0.j, 1. + 0.j]])
        assert np.all(com_graph.adj == correct_cg)

        # test that this is the same
        clique_covering = weighted_vertex_covering_maximal_cliques(com_graph, cc=P.weights, k=100)
        xxx = sorted(clique_covering)
        correct_xxx = [[0, 1], [0, 2], [0, 6], [1, 3], [1, 4, 9], [2, 3, 7], [2, 4, 8, 9], [3, 5],
                       [5, 8], [6, 7], [6, 8]]
        assert xxx == correct_xxx

        # Check that the circuits are the same
        circuit_list, circuit_dictionary = construct_circuit_list(P, sorted(clique_covering), {})
        correct_circuit_list = [[('S', [0]), ('S', [1]), ('S', [2]), ('H', [0]), ('H', [1]), ('H', [2])],
                                [('SUM', [0, 1]), ('SUM', [0, 2]), ('SUM', [1, 0]), ('SUM', [2, 0]), ('S', [0]),
                                ('SUM', [1, 2]), ('S', [1]), ('H', [0]), ('H', [1])],
                                [('SUM', [0, 1]), ('SUM', [0, 2]), ('SUM', [1, 0]), ('SUM', [2, 0]), ('S', [0]),
                                ('H', [0]), ('H', [1])],
                                [('S', [2]), ('H', [2])],
                                [('S', [1]), ('S', [2]), ('H', [0]), ('H', [1]), ('H', [2])],
                                [('S', [0]), ('SUM', [2, 0]), ('S', [0]), ('SUM', [1, 2]), ('S', [1]), ('H', [0]),
                                ('H', [1]), ('H', [2])],
                                [('S', [1]), ('H', [0]), ('H', [1])],
                                [('SUM', [2, 0]), ('S', [0]), ('H', [0]), ('H', [2])],
                                [('S', [0]), ('S', [1]), ('H', [0]), ('H', [1])],
                                [('SUM', [0, 1]), ('SUM', [0, 2]), ('S', [0]), ('SUM', [1, 0]), ('S', [0]), ('S', [1]),
                                ('SUM', [2, 1]), ('S', [1]), ('H', [0]), ('H', [1])],
                                [('S', [1]), ('H', [1])]]

        for i, c in enumerate(circuit_list):
            comp_c = correct_circuit_list[i]
            for j, g in enumerate(c.gates):
                assert g.name == comp_c[j][0] and np.all(g.qudit_indices == comp_c[j][1])

        correct_pdf_list = [np.array([0.02542707, 0.12897405, 0.08068772, 0.05845028, 0.36295372, 0.1421931,
                                      0.05060223, 0.15071182]),
                            np.array([0.09318501, 0.30005449, 0.15304774, 0.17704009, 0.10752054, 0.07545655,
                                      0.06534823, 0.02834737]),
                            np.array([0.44466921, 0.21183354, 0.019566, 0.04725856, 0.09619328, 0.14315368,
                                      0.02446649, 0.01285923]),
                            np.array([0.18978089, 0.1585293, 0.02944028, 0.15439375, 0.09267961, 0.08799103,
                                      0.20776996, 0.07941517]),
                            np.array([0.25705659, 0.15511907, 0.1209376, 0.17569991, 0.1313242, 0.11604808,
                                      0.01035235, 0.03346219]),
                            np.array([0.04864252, 0.02594369, 0.05530455, 0.35704434, 0.17937638, 0.20819559,
                                      0.05100822, 0.07448471]),
                            np.array([0.23757947, 0.17459619, 0.22452135, 0.07211616, 0.23109066, 0.01628162,
                                      0.00913208, 0.03468246]),
                            np.array([0.26060613, 0.01264472, 0.03943729, 0.0049216, 0.23856419, 0.0171658,
                                      0.35724211, 0.06941816]),
                            np.array([0.02260509, 0.13179603, 0.13413112, 0.00500688, 0.44606504, 0.05908179,
                                      0.09952231, 0.10179175]),
                            np.array([0.09774939, 0.02266323, 0.20535566, 0.13638989, 0.26378004, 0.08830288,
                                      0.0180099, 0.16774901]),
                            np.array([0.33469847, 0.05644059, 0.07498291, 0.06602225, 0.13397166, 0.13443723,
                                      0.15867052, 0.04077638])]

        for i, aa in enumerate(xxx):
            P1, C, _ = circuit_dictionary[str(aa)]
            psi_diag = C.unitary() @ psi
            pdf = np.abs(psi_diag * psi_diag.conj())
            assert np.allclose(pdf, correct_pdf_list[i])

        simulated_measurement_results = [np.array([1, 1, 1]),
                                         np.array([0, 1, 1]),
                                         np.array([0, 0, 0]),
                                         np.array([0, 0, 1]),
                                         np.array([0, 1, 1]),
                                         np.array([0, 1, 1]),
                                         np.array([0, 1, 1]),
                                         np.array([0, 0, 0]),
                                         np.array([1, 0, 0]),
                                         np.array([0, 1, 1]),
                                         np.array([1, 0, 0])]

        data = np.zeros((P.n_paulis(), P.n_paulis(), P.lcm))
        d = len(data[0, 0])

        correct_results = [[[0, 0, 0], [1, 1, 0], [0, 1, 0], [1, 0, 0]],
                           [[0, 0, 0], [2, 2, 0], [0, 2, 0], [2, 0, 0]],
                           [[0, 0, 0], [6, 6, 1], [0, 6, 1], [6, 0, 1]],
                           [[1, 1, 0], [3, 3, 0], [1, 3, 0], [3, 1, 0]],
                           [[1, 1, 0], [4, 4, 0], [9, 9, 0], [1, 4, 0], [4, 1, 0],
                            [1, 9, 0], [9, 1, 0], [4, 9, 0], [9, 4, 0]],
                           [[2, 2, 1], [3, 3, 0], [7, 7, 1], [2, 3, 1], [3, 2, 1],
                            [2, 7, 0], [7, 2, 0], [3, 7, 1], [7, 3, 1]],
                           [[2, 2, 1], [4, 8, 1], [8, 4, 1], [4, 4, 0], [2, 8, 0], [8, 2, 0], [8, 8, 1], [2, 4, 1],
                            [4, 2, 1], [9, 9, 0], [2, 9, 1], [9, 2, 1], [4, 9, 0], [9, 4, 0], [8, 9, 1], [9, 8, 1]],
                           [[3, 3, 1], [5, 5, 1], [3, 5, 0], [5, 3, 0]],
                           [[5, 5, 0], [8, 8, 1], [5, 8, 1], [8, 5, 1]],
                           [[6, 6, 1], [7, 7, 0], [6, 7, 1], [7, 6, 1]],
                           [[6, 6, 0], [8, 8, 1], [6, 8, 1], [8, 6, 1]]]

        for i, aa in enumerate(xxx):
            (P1, C, k_dict) = circuit_dictionary[str(aa)]
            p1, q1, phases1 = P1.n_paulis(), P1.n_qudits(), P1.phases

            bases_a1 = simulated_measurement_results[i]

            ss = [(sum((bases_a1[i1] * P1.z_exp[i0, i1] * P1.lcm) // P1.dimensions[i1]
                       for i1 in range(q1))) % P1.lcm for i0 in range(p1)]

            comp_correct_results = correct_results[i]
            j = 0
            for j0, s0 in enumerate(ss):
                for a0, a1, s1 in k_dict[str(j0)]:
                    assert (phases1[j0] + s1) % 2 != 1
                    assert (a0 == comp_correct_results[j][0] and a1 == comp_correct_results[j][1] and
                            int(s0 + (phases1[j0] + s1) / 2) % d == comp_correct_results[j][2])
                    j += 1

    def test_aquire_for_specific_mono_qudit(self):
        P = PauliSum(['x2z2 x2z0 x0z0 ',
                      'x1z1 x1z0 x0z0 ',
                      'x2z1 x1z2 x1z1 ',
                      'x1z2 x2z1 x2z2 ',
                      'x2z2 x1z0 x0z1 ',
                      'x1z1 x2z0 x0z2 ',
                      'x2z1 x0z2 x0z2 ',
                      'x1z2 x0z1 x0z1 ',
                      'x2z1 x0z1 x0z0 ',
                      'x1z2 x0z2 x0z0 ',
                      'x2z0 x0z0 x0z2 ',
                      'x1z0 x0z0 x0z1 ',
                      'x0z0 x2z1 x2z0 ',
                      'x0z0 x1z2 x1z0 ',
                      'x0z2 x2z2 x1z0 ',
                      'x0z1 x1z1 x2z0 ',
                      'x0z2 x2z0 x1z0 ',
                      'x0z1 x1z0 x2z0 ',
                      'x0z1 x2z0 x1z0 ',
                      'x0z2 x1z0 x2z0 '],
                     weights=np.array([-0.5+0.8660254j, 1. +0j, -0.5-0.8660254j, 1. +0j, -0.5+0.8660254j, 1. +0j,
                                      -0.5-0.8660254j, 1. +0j, 1. +0j, -0.5-0.8660254j, 1. +0j, 1. +0j, -0.5-0.8660254j,
                                      1. +0j, 1. +0j, -0.5+0.8660254j, 1. +0j, 1. +0j, 1. +0j, 1. +0j]),
                     dimensions=[3,3,3],
                     standardise=False)

        P, _ = sort_hamiltonian(P)

        assert P.is_hermitian(mode='scipy')

        psi = np.array([0.0243169 +0.13333766j, 0.23225686+0.01878849j, 0.14274615+0.20139411j, 0.21479966+0.16158387j,
                        0.04977999+0.22823104j, 0.18769378+0.05949222j, 0.15391192+0.06717867j, 0.09354094+0.1232698j ,
                        0.05537587+0.21819983j, 0.00393039+0.01681437j, 0.19299884+0.18595263j, 0.17220807+0.19552373j,
                        0.01249742+0.06402695j, 0.03737155+0.09736036j, 0.17287483+0.02595331j, 0.1046728 +0.04925145j,
                        0.14569767+0.01744369j, 0.13833252+0.05140952j, 0.19480008+0.11880762j, 0.17876016+0.06101845j,
                        0.19297524+0.12974931j, 0.09315548+0.16390813j, 0.10666972+0.17861801j, 0.17352167+0.02847061j,
                        0.04007118+0.20151664j, 0.06101652+0.03587477j, 0.23395682+0.04552155j])

        com_graph = commutation_graph(P)
        correct_commutation_graph = np.array([[1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
                                              [1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j,
                                                  0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,
                                               1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j],
                                              [0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,
                                               1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j],
                                              [1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j,
                                               0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],
                                              [1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j,
                                               0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j,
                                               0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j,
                                               0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
                                              [1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j,
                                               0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j],
                                              [1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j,
                                               0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j],
                                              [0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,
                                               1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j],
                                              [0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,
                                               1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j],
                                              [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,
                                               0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,
                                               0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,
                                               0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,
                                               0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,
                                               0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j],
                                              [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,
                                               0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j],
                                              [0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j,
                                               1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j],
                                              [0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j]])

        assert np.all(com_graph.adj == correct_commutation_graph)

        # test that this is the same
        clique_covering = weighted_vertex_covering_maximal_cliques(com_graph, cc=P.weights, k=100)
        xxx = sorted(clique_covering)
        correct_xxx = [[0, 1, 4, 5], [0, 1, 8, 9], [2, 3, 10, 11, 18, 19], [4, 5, 6, 7], [
            4, 5, 16, 17], [6, 7, 8, 9], [8, 9, 18, 19], [12, 13], [14, 15], [16, 17, 18, 19]]
        assert xxx == correct_xxx

        # Check that the circuits are the same
        circuit_list, circuit_dictionary = construct_circuit_list(P, sorted(clique_covering), {})
        correct_ciruit_list = [[('S', [0]), ('S', [0]), ('H', [0]), ('H', [1])],
                               [('SUM', [0, 1]), ('SUM', [0, 1]), ('S', [0]), ('S', [0]),
                                ('S', [1]), ('S', [1]), ('H', [0]), ('H', [1])],
                               [('SUM', [0, 1]), ('SUM', [0, 2]), ('SUM', [1, 0]), ('SUM', [2, 0]), ('SUM', [1, 0]), ('S', [0]), ('SUM', [1, 2]), ('SUM', [
                                   1, 2]), ('SUM', [2, 1]), ('SUM', [2, 1]), ('S', [1]), ('S', [1]), ('S', [2]), ('S', [2]), ('H', [0]), ('H', [1]), ('H', [2])],
                               [('SUM', [0, 1]), ('SUM', [2, 0]), ('SUM', [2, 0]), ('S', [0]), ('S', [0]),
                                ('SUM', [2, 1]), ('SUM', [2, 1]), ('S', [1]), ('S', [1]), ('H', [0]), ('H', [1])],
                               [('SUM', [0, 1]), ('SUM', [2, 0]), ('SUM', [2, 0]), ('S', [0]), ('S', [0]),
                                ('SUM', [1, 2]), ('SUM', [2, 1]), ('SUM', [2, 1]), ('S', [1]), ('H', [0]), ('H', [1])],
                               [('S', [0]), ('H', [0])],
                               [('SUM', [1, 0]), ('S', [0]), ('SUM', [1, 2]),
                                ('S', [1]), ('S', [1]), ('H', [0]), ('H', [1])],
                               [('S', [1]), ('H', [1]), ('H', [2])],
                               [('S', [1]), ('S', [1]), ('H', [1]), ('H', [2])],
                               [('H', [1]), ('H', [2])]]

        for i,c in enumerate(circuit_list):
            comp_c = correct_ciruit_list[i]
            for j, g in enumerate(c.gates):
                assert g.name == comp_c[j][0] and np.all(g.qudit_indices == comp_c[j][1])

        correct_pdf_list = [np.array([6.59161444e-02, 8.02150363e-02, 6.36243965e-02, 2.17680172e-02, 3.29055261e-03, 1.87546042e-02, 7.74362539e-03, 6.53314911e-03, 9.75691566e-05, 3.65793915e-02, 8.17840670e-02, 1.90521408e-01, 8.62538668e-03, 4.91780968e-03, 1.51418111e-03, 4.74498174e-04, 2.90909439e-03, 1.76982765e-02, 1.17257790e-01, 7.33296223e-02, 1.08717592e-01, 5.81814011e-03, 7.10622581e-03, 1.12549611e-02, 2.39404690e-03, 6.09294875e-02, 2.24925503e-04]),
                            np.array([0.0135236 , 0.02287538, 0.07313852, 0.04144613, 0.0231289 , 0.01759941, 0.01723905, 0.04422607, 0.0018397 , 0.02358743, 0.06587151, 0.08546266, 0.03688045,
                                     0.07318583, 0.02919063, 0.00027358, 0.00694677, 0.09484765, 0.03822441, 0.02253941, 0.03143263, 0.08353259, 0.00718997, 0.04605496, 0.01186979, 0.0550512 , 0.03284175]),
                            np.array([0.01227258, 0.02210411, 0.03213838, 0.06253631, 0.10663692, 0.00464668, 0.03475378, 0.03085721, 0.01632825, 0.0459643 , 0.02044448, 0.02630505, 0.10628538,
                                     0.07778881, 0.05519194, 0.0268313 , 0.03817419, 0.03587107, 0.04349402, 0.03996942, 0.02044398, 0.02971498, 0.02362896, 0.00387816, 0.00729071, 0.06502106, 0.01142796]),
                            np.array([0.02048224, 0.04212302, 0.00216514, 0.02993187, 0.02600585, 0.0937533 , 0.02652146, 0.02729458, 0.04925203, 0.01080454, 0.02335932, 0.01623029, 0.01961622,
                                     0.0318068 , 0.01798273, 0.0197204 , 0.02436314, 0.03115049, 0.01154127, 0.00023335, 0.09768908, 0.0764049 , 0.08936188, 0.06315144, 0.05155413, 0.05646711, 0.04103342]),
                            np.array([0.0383909 , 0.04210919, 0.01590876, 0.04815273, 0.00930026, 0.01955169, 0.04754097, 0.0262308 , 0.07034419, 0.02917794, 0.00520156, 0.01829537, 0.04812309,
                                     0.01097835, 0.00655751, 0.02665757, 0.03412917, 0.01591336, 0.0268926 , 0.12949704, 0.01738394, 0.02872738, 0.07491332, 0.12835941, 0.00759387, 0.03682382, 0.03724521]),
                            np.array([0.03230439, 0.0627921 , 0.08680755, 0.01727597, 0.04087597, 0.03704394, 0.0022125 , 0.0208018 , 0.06780238, 0.03404063, 0.01575433, 0.05092214, 0.05108074,
                                     0.05179103, 0.03804879, 0.04061216, 0.02698124, 0.05296111, 0.00438572, 0.08325521, 0.04516584, 0.04369099, 0.01605894, 0.02515518, 0.04097395, 0.00270442, 0.00850099]),
                            np.array([0.01944395, 0.05153482, 0.07873739, 0.05333112, 0.03358082, 0.03947276, 0.00028253, 0.03725819, 0.06136238, 0.02834517, 0.02212939, 0.02856431, 0.02728588,
                                     0.03669945, 0.00850745, 0.02436656, 0.06841886, 0.03212182, 0.032282  , 0.0400476 , 0.02629502, 0.03128373, 0.02772186, 0.02192118, 0.00484517, 0.08572282, 0.07843777]),
                            np.array([0.09564645, 0.00399907, 0.00264297, 0.09677284, 0.00824304, 0.03561417, 0.12410063, 0.005804  , 0.0291882 , 0.09247727, 0.02202712, 0.00608497, 0.06816354,
                                     0.0049469 , 0.02109672, 0.02090848, 0.00333723, 0.00335163, 0.10731017, 0.00119354, 0.00468997, 0.07647734, 0.00229109, 0.02503225, 0.11158595, 0.01187198, 0.01514246]),
                            np.array([0.13601593, 0.00555376, 0.00689171, 0.0949811 , 0.00979787, 0.02425467, 0.0855229 , 0.00269447, 0.03629897, 0.03176591, 0.01854943, 0.00352163, 0.07124663,
                                     0.00693303, 0.0197805 , 0.07853676, 0.00482879, 0.00723117, 0.12189132, 0.00124994, 0.01543726, 0.05340347, 0.01033514, 0.02304362, 0.12007868, 0.00377153, 0.0063838]),
                            np.array([3.11151518e-01, 1.82878877e-03, 1.06575490e-03, 3.43664166e-04, 1.28398168e-04, 5.38554170e-02, 5.02474774e-03, 1.60889224e-02, 1.25241711e-02, 1.61865503e-01, 1.92320068e-02, 9.44542185e-03, 1.15377437e-03, 6.27698323e-03, 1.17308916e-02, 1.85300175e-02, 4.80226348e-03, 9.35699814e-03, 2.83749116e-01, 4.85501400e-03, 2.47523249e-02, 2.08454105e-03, 5.52640626e-03, 1.94980266e-03, 9.53981418e-03, 4.97518792e-03, 1.81625502e-02])]

        for i,aa in enumerate(xxx):
            P1, C, _ = circuit_dictionary[str(aa)]
            psi_diag = C.unitary() @ psi
            pdf = np.abs(psi_diag * psi_diag.conj())
            assert np.allclose(pdf, correct_pdf_list[i])

        simulated_measurement_results = [np.array([0, 0, 1]),
                                         np.array([1, 1, 0]),
                                         np.array([1, 1, 1]),
                                         np.array([2, 2, 1]),
                                         np.array([2, 0, 1]),
                                         np.array([2, 1, 2]),
                                         np.array([2, 0, 2]),
                                         np.array([2, 2, 0]),
                                         np.array([0, 0, 0]),
                                         np.array([2, 0, 0])]

        d = P.lcm

        correct_results = [[[0, 0, 2], [0, 1, 1], [1, 1, 0], [1, 0, 2], [4, 4, 0], [4, 5, 2], [5, 5, 2], [5, 4, 1], [0, 4, 1], [5, 1, 1], [0, 5, 0], [4, 1, 0], [1, 4, 0], [5, 0, 0], [1, 5, 2], [4, 0, 2]],
                           [[0, 0, 1], [0, 1, 0], [1, 1, 1], [1, 0, 0], [8, 8, 2], [8, 9, 0], [9, 9, 2], [9, 8, 0], [
                               0, 8, 1], [9, 1, 2], [0, 9, 1], [8, 1, 2], [1, 8, 1], [9, 0, 2], [1, 9, 1], [8, 0, 2]],
                           [[2, 2, 0], [2, 3, 1], [3, 3, 1], [3, 2, 2], [10, 10, 1], [10, 11, 1], [11, 11, 2], [11, 10, 2], [18, 18, 1], [18, 19, 1], [19, 19, 2], [19, 18, 2], [2, 10, 1], [11, 3, 2], [2, 11, 2], [10, 3, 0], [2, 18, 1], [19, 3, 2], [
                               2, 19, 2], [18, 3, 0], [3, 10, 0], [11, 2, 1], [3, 11, 1], [10, 2, 2], [3, 18, 0], [19, 2, 1], [3, 19, 1], [18, 2, 2], [10, 18, 0], [19, 11, 0], [10, 19, 1], [18, 11, 1], [11, 18, 2], [19, 10, 2], [11, 19, 0], [18, 10, 0]],
                           [[4, 4, 0], [4, 5, 2], [5, 5, 2], [5, 4, 1], [6, 6, 0], [6, 7, 1], [7, 7, 1], [7, 6, 2], [
                               4, 6, 0], [7, 5, 1], [4, 7, 1], [6, 5, 2], [5, 6, 1], [7, 4, 2], [5, 7, 2], [6, 4, 0]],
                           [[4, 4, 0], [4, 5, 2], [5, 5, 2], [5, 4, 1], [16, 16, 1], [16, 17, 1], [17, 17, 2], [17, 16, 2], [
                               4, 16, 1], [17, 5, 0], [4, 17, 2], [16, 5, 1], [5, 16, 2], [17, 4, 1], [5, 17, 0], [16, 4, 2]],
                           [[6, 6, 2], [6, 7, 0], [7, 7, 2], [7, 6, 0], [8, 8, 0], [8, 9, 1], [9, 9, 1], [9, 8, 2], [
                               6, 8, 1], [9, 7, 1], [6, 9, 2], [8, 7, 2], [7, 8, 1], [9, 6, 1], [7, 9, 2], [8, 6, 2]],
                           [[8, 8, 2], [8, 9, 0], [9, 9, 2], [9, 8, 0], [18, 18, 1], [18, 19, 1], [19, 19, 2], [19, 18, 2], [
                               8, 18, 2], [19, 9, 0], [8, 19, 0], [18, 9, 1], [9, 18, 2], [19, 8, 0], [9, 19, 0], [18, 8, 1]],
                           [[12, 12, 2], [12, 13, 0], [13, 13, 2], [13, 12, 0]],
                           [[14, 14, 2], [14, 15, 1], [15, 15, 0], [15, 14, 2]],
                           [[16, 16, 1], [16, 17, 1], [17, 17, 2], [17, 16, 2], [18, 18, 2], [18, 19, 2], [19, 19, 1], [19, 18, 1], [16, 18, 1], [19, 17, 1], [16, 19, 0], [18, 17, 0], [17, 18, 0], [19, 16, 0], [17, 19, 2], [18, 16, 2]]]

        for i, aa in enumerate(xxx):
            (P1, C, k_dict) = circuit_dictionary[str(aa)]
            p1, q1, phases1 = P1.n_paulis(), P1.n_qudits(), P1.phases

            bases_a1 = simulated_measurement_results[i]

            ss = [(sum((bases_a1[i1] * P1.z_exp[i0, i1] * P1.lcm) // P1.dimensions[i1]
                       for i1 in range(q1))) % P1.lcm for i0 in range(p1)]

            comp_correct_results = correct_results[i]
            j = 0
            for j0, s0 in enumerate(ss):
                for a0, a1, s1 in k_dict[str(j0)]:
                    assert (phases1[j0] + s1) % 2 != 1
                    assert (a0 == comp_correct_results[j][0] and a1 == comp_correct_results[j][1] and int(
                        s0 + (phases1[j0]+s1)/2)%d == comp_correct_results[j][2])
                    j += 1

    def test_aquire_for_specific_mixed_qubit_qutrit(self):
        P = PauliSum(['x0z1 x2z2 x0z1',
                      'x0z1 x1z1 x0z2',
                      'x1z0 x0z1 x0z1',
                      'x1z0 x0z2 x0z2',
                      'x1z1 x2z0 x0z0',
                      'x1z1 x1z0 x0z0',
                      'x0z1 x1z1 x0z1',
                      'x0z1 x2z2 x0z2',
                      'x0z0 x0z1 x0z2',
                      'x0z0 x0z2 x0z1',
                      'x0z0 x1z2 x2z1',
                      'x0z0 x2z1 x1z2',
                      'x0z1 x0z1 x1z1',
                      'x0z1 x0z2 x2z2',
                      'x0z0 x2z0 x1z1',
                      'x0z0 x1z0 x2z2',
                      'x0z1 x0z2 x2z1',
                      'x0z1 x0z1 x1z2',
                      'x0z0 x1z1 x2z2',
                      'x0z0 x2z2 x1z1'],
                     weights=np.array([(-0.1488386951213129-0.24458483710762013j),
                                      (-0.13739733475502164-0.2511905095949939j),
                                       (0.39790491462228145+0.3144791368172083j),
                                       (0.39790491462228145-0.3144791368172083j),
                                       (1.7562538741961349+0.8008004095888523j),
                                       (-1.7562538741961349+0.8008004095888526j),
                                       (-1.7347864790941196-0.719735083025615j),
                                       (0.24408437365197477-1.862236702550077j),
                                       (0.997720528409078+0.45882200325077704j),
                                       (0.997720528409078-0.45882200325077704j),
                                       (-0.5075532135307834+0.957069354787535j),
                                       (1.0826229811949788+0.03898070070368048j),
                                       (0.032148128730882033+0.38671229011424774j),
                                       (0.31882860282915537+0.22119724122220003j),
                                       (1.0555664896831631-0.31940278541218503j),
                                       (-0.8043941710480433+0.7544460027430915j),
                                       (0.08764238674375009-0.3756187621401411j),
                                       (0.28147419677955154-0.26370991443845876j),
                                       (0.10255029347634882-0.7186218339232213j),
                                       (0.5710696171534966-0.44812207627767886j)]),
                     dimensions=[2,3,3],
                     standardise=False)

        P, _ = sort_hamiltonian(P)

        assert P.is_hermitian(mode='scipy')

        psi = np.array([0.95658755+0.3345133j ,
                        0.82673942+0.02393923j,
                        0.73725229+0.0043007j ,
                        0.4155579 +0.09368815j,
                        0.69320243+0.414466j  ,
                        0.30758268+0.11154834j,
                        0.81406806+0.00896708j,
                        0.73671334+0.45949789j,
                        0.13827358+0.86435367j,
                        0.37875798+0.64068182j,
                        0.62016015+0.46381568j,
                        0.03648609+0.10743318j,
                        0.66940006+0.42004086j,
                        0.51950955+0.62863876j,
                        0.62014527+0.58585594j,
                        0.88222837+0.26807491j,
                        0.31104378+0.85852868j,
                        0.90056666+0.11640313j])

        psi = psi/np.linalg.norm(psi)

        com_graph = commutation_graph(P)
        correct_commutation_graph = np.array([[1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
                                              [1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j,
                                                  1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j,
                                               1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j],
                                              [0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j,
                                               1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j],
                                              [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,
                                               0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,
                                               0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
                                              [1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j,
                                               0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],
                                              [1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j,
                                               0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j,
                                               0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j,
                                               0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
                                              [1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,
                                               1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
                                              [1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,
                                               1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j,
                                               0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j,
                                               0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j,
                                               1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j,
                                               1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],
                                              [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j,
                                               0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j],
                                              [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j,
                                               0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j],
                                              [0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,
                                               0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j],
                                              [0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j]])

        assert np.all(com_graph.adj == correct_commutation_graph)

        clique_covering = weighted_vertex_covering_maximal_cliques(com_graph, cc=P.weights, k=100)
        xxx = sorted(clique_covering)
        correct_xxx = [[0, 1, 6, 7], [0, 1, 10, 11], [2, 3, 8, 9], [2, 3, 10, 11, 14, 15], [
            2, 3, 18, 19], [4, 5, 14, 15], [6, 7, 12, 13], [6, 7, 14, 15, 16, 17], [16, 17, 18, 19]]

        assert xxx == correct_xxx

        circuit_list, circuit_dictionary = construct_circuit_list(P, sorted(clique_covering), {})
        correct_ciruit_list = [[('S', [1]), ('S', [1]), ('H', [1])],
                               [('SUM', [2, 1]), ('SUM', [2, 1]), ('S', [1]), ('S', [1]), ('H', [1]), ('H', [2])],
                               [('H', [0])],
                               [('SUM', [1, 2]), ('SUM', [2, 1]), ('S', [1]), ('S', [1]), ('H', [0]), ('H', [1])],
                               [('SUM', [1, 2]), ('SUM', [2, 1]), ('S', [1]), ('H', [0]), ('H', [1])],
                               [('S', [0]), ('S', [2]), ('S', [2]), ('H', [0]), ('H', [1]), ('H', [2])],
                               [('SUM', [2, 1]), ('S', [1]), ('S', [1]), ('H', [1]), ('H', [2])],
                               [('SUM', [2, 1]), ('S', [1]), ('S', [1]), ('S', [2]), ('S', [2]), ('H', [1]), ('H', [2])],
                               [('SUM', [1, 2]), ('SUM', [2, 1]), ('S', [1]), ('H', [1]), ('H', [2])]]

        for i,c in enumerate(circuit_list):
            comp_c = correct_ciruit_list[i]
            for j, g in enumerate(c.gates):
                assert g.name == comp_c[j][0] and np.all(g.qudit_indices == comp_c[j][1])

        correct_pdf_list = [np.array([0.03088027, 0.0778431 , 0.09524126, 0.05664266, 0.03303774, 0.00358182, 0.08149876, 0.07792758, 0.02915606, 0.0220013 , 0.09453924, 0.00347217, 0.11070641, 0.04113357, 0.08810741, 0.05053518, 0.05389007, 0.04980541]),
                            np.array([0.08199209, 0.00346635, 0.00761564, 0.21656557, 0.00913186, 0.00411407, 0.10786129, 0.0381335 , 0.01692888,
                                     0.08491302, 0.01797239, 0.01005487, 0.12083467, 0.00685999, 0.04037399, 0.22640233, 0.00106115, 0.00571835]),
                            np.array([0.12348446, 0.10529568, 0.02760204, 0.0650832 , 0.11556206, 0.06083784, 0.1334214 , 0.12803858, 0.09218239,
                                     0.01931318, 0.01066614, 0.02265906, 0.00772037, 0.00343421, 0.01457266, 0.00324197, 0.01537463, 0.05151013]),
                            np.array([0.12509383, 0.08697523, 0.1085695 , 0.07181881, 0.12556805, 0.1363342 , 0.11544823, 0.050018  , 0.0316818 ,
                                     0.01486899, 0.01480947, 0.01760896, 0.02535907, 0.01797561, 0.00443047, 0.00903241, 0.03711156, 0.00729581]),
                            np.array([0.06093234, 0.10346923, 0.14488784, 0.1397243 , 0.10876443, 0.10514202, 0.11170423, 0.05032761, 0.02655564,
                                     0.0030634 , 0.00127322, 0.00088036, 0.04534933, 0.01834359, 0.02023993, 0.00084774, 0.05027982, 0.00821495]),
                            np.array([0.0995263 , 0.0705217 , 0.10887931, 0.02329567, 0.01785643, 0.03898479, 0.00212796, 0.01320254, 0.0068507 ,
                                     0.25544439, 0.10873075, 0.19132325, 0.0125137 , 0.00643872, 0.01397883, 0.00359616, 0.01864258, 0.00808623]),
                            np.array([0.07013304, 0.01533057, 0.02692606, 0.1226698 , 0.00596643, 0.03500559, 0.19604677, 0.00322508, 0.0105059 ,
                                     0.15171191, 0.00836811, 0.00391876, 0.2295275 , 0.00581705, 0.01970651, 0.06851384, 0.00138866, 0.02523842]),
                            np.array([0.08573838, 0.01340775, 0.01324355, 0.12402213, 0.01272169, 0.02689799, 0.03512596, 0.06405263, 0.11059917,
                                     0.04164785, 0.06572724, 0.05662368, 0.06600242, 0.07363537, 0.11541328, 0.04166603, 0.0083955 , 0.04507939]),
                            np.array([0.15091531, 0.00737525, 0.00096262, 0.21057304, 0.01519798, 0.01968833, 0.04493059, 0.00608536, 0.03008075, 0.1330255 , 0.01110966, 0.01111805, 0.16044855, 0.02213106, 0.00952464, 0.13867597, 0.02290649, 0.00525084])]

        for i,aa in enumerate(xxx):
            P1, C, _ = circuit_dictionary[str(aa)]
            psi_diag = C.unitary() @ psi
            pdf = np.abs(psi_diag * psi_diag.conj())
            assert np.allclose(pdf, correct_pdf_list[i])

        simulated_measurement_results = [np.array([0, 0, 0]),
                                         np.array([0, 2, 1]),
                                         np.array([0, 0, 0]),
                                         np.array([1, 2, 0]),
                                         np.array([0, 0, 0]),
                                         np.array([0, 1, 2]),
                                         np.array([1, 0, 0]),
                                         np.array([0, 1, 2]),
                                         np.array([1, 0, 0])]

        d = P.lcm

        correct_results = [[[0, 0, 4], [1, 1, 0], [6, 6, 0], [7, 7, 4], [0, 1, 2], [0, 6, 2], [7, 1, 2], [0, 7, 0], [6, 1, 0], [1, 0, 4], [1, 6, 0], [7, 0, 0], [1, 7, 4], [6, 0, 4], [6, 7, 4], [7, 6, 2]], [[0, 0, 3], [1, 1, 1], [10, 10, 0], [10, 11, 4], [11, 11, 4], [11, 10, 2], [0, 1, 4], [0, 10, 3], [11, 1, 3], [0, 11, 1], [10, 1, 1], [1, 0, 2], [1, 10, 5], [11, 0, 5], [1, 11, 3], [10, 0, 3]], [[2, 2, 2], [3, 3, 4], [8, 8, 0], [8, 9, 0], [9, 9, 0], [9, 8, 0], [2, 3, 2], [2, 8, 4], [9, 3, 4], [2, 9, 4], [8, 3, 4], [3, 2, 4], [3, 8, 2], [9, 2, 2], [3, 9, 2], [8, 2, 2]], [[2, 2, 0], [3, 3, 0], [10, 10, 2], [10, 11, 0], [11, 11, 2], [11, 10, 0], [14, 14, 2], [14, 15, 0], [15, 15, 2], [15, 14, 0], [2, 3, 0], [10, 15, 0], [14, 11, 0], [2, 10, 2], [3, 15, 2], [11, 3, 4], [14, 2, 4], [2, 11, 2], [10, 3, 4], [2, 14, 2], [3, 11, 2], [10, 2, 4], [15, 3, 4], [2, 15, 2], [14, 3, 4], [3, 2, 0], [11, 14, 0], [15, 10, 0], [3, 10, 2], [11, 2, 4], [3, 14, 2], [15, 2, 4], [10, 14, 0], [15, 11, 0], [11, 15, 0], [14, 10, 0]], [[2, 2, 0], [3, 3, 0], [18, 18, 2], [18, 19, 4], [19, 19, 0], [19, 18, 2], [2, 3, 0], [2, 18, 2], [19, 3, 0], [
            2, 19, 0], [18, 3, 4], [3, 2, 0], [3, 18, 2], [19, 2, 0], [3, 19, 0], [18, 2, 4]], [[4, 4, 3], [5, 5, 3], [14, 14, 4], [14, 15, 2], [15, 15, 0], [15, 14, 4], [4, 5, 0], [4, 14, 1], [15, 5, 3], [4, 15, 3], [14, 5, 5], [5, 4, 0], [5, 14, 1], [15, 4, 3], [5, 15, 3], [14, 4, 5]], [[6, 6, 4], [7, 7, 0], [12, 12, 4], [13, 13, 0], [6, 7, 2], [6, 12, 0], [13, 7, 0], [6, 13, 2], [12, 7, 2], [7, 6, 4], [7, 12, 4], [13, 6, 4], [7, 13, 0], [12, 6, 0], [12, 13, 2], [13, 12, 4]], [[6, 6, 4], [14, 17, 4], [16, 15, 0], [7, 7, 0], [15, 16, 0], [17, 14, 2], [14, 14, 4], [6, 17, 4], [14, 15, 2], [16, 7, 0], [15, 15, 0], [7, 16, 0], [15, 14, 4], [17, 6, 2], [16, 16, 0], [6, 15, 2], [14, 7, 2], [17, 17, 2], [7, 14, 4], [15, 6, 4], [6, 7, 2], [6, 14, 0], [14, 16, 2], [15, 7, 0], [17, 15, 4], [6, 16, 2], [17, 7, 4], [7, 6, 4], [7, 15, 0], [14, 6, 0], [15, 17, 2], [16, 14, 4], [7, 17, 2], [16, 6, 4], [16, 17, 2], [17, 16, 4]], [[16, 16, 3], [17, 17, 5], [18, 18, 2], [18, 19, 4], [19, 19, 0], [19, 18, 2], [16, 17, 2], [16, 18, 5], [19, 17, 5], [16, 19, 3], [18, 17, 3], [17, 16, 4], [17, 18, 3], [19, 16, 3], [17, 19, 1], [18, 16, 1]]]

        for i, aa in enumerate(xxx):
            (P1, C, k_dict) = circuit_dictionary[str(aa)]
            p1, q1, phases1 = P1.n_paulis(), P1.n_qudits(), P1.phases

            bases_a1 = simulated_measurement_results[i]

            ss = [(sum((bases_a1[i1] * P1.z_exp[i0, i1] * P1.lcm) // P1.dimensions[i1]
                       for i1 in range(q1))) % P1.lcm for i0 in range(p1)]

            comp_correct_results = correct_results[i]
            j = 0
            for j0, s0 in enumerate(ss):
                for a0, a1, s1 in k_dict[str(j0)]:
                    assert (phases1[j0] + s1) % 2 != 1
                    assert (a0 == comp_correct_results[j][0] and a1 == comp_correct_results[j][1])
                    assert (a0 == comp_correct_results[j][0] and a1 == comp_correct_results[j][1] and int(
                        s0 + (phases1[j0]+s1)/2)%d == comp_correct_results[j][2])
                    j += 1

    def test_aquire_for_specific_mixed_qubit_qudit_2(self):
        pass